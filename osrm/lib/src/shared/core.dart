import 'dart:convert';

import 'package:http/http.dart';
import 'package:osrm/src/builders.dart';
import 'package:recase/recase.dart';

import '../../osrm.dart';
import 'utils.dart';

/// [OsrmService] enum for the service to use for the request
enum OsrmService {
  nearest,
  route,
  match,
  trip,
  table,
}

/// [OsrmRequestProfile] enum for the mode of transportation
enum OsrmRequestProfile {
  /// [bike] for cycling
  bike,

  /// [foot] for walking
  foot,

  /// [car] for driving
  car;

  /// [traffic] driving traffic
  // traffic;

  // override name getter
  String get name {
    switch (this) {
      case OsrmRequestProfile.car:
        return 'driving';
      case OsrmRequestProfile.bike:
        return 'bike';
      case OsrmRequestProfile.foot:
        return 'foot';
      default:
        throw Exception('Invalid profile: $this');
    }
  }
}

/// [OsrmFormat] enum for the format of the response
enum OsrmFormat {
  /// [json] for json
  json,

  /// [flatbuffers] for flatbuffers (not implemented!)
  flatbuffers,
}

/// [OsrmApproach] enum for the approach to a coordinate
enum OsrmApproach {
  /// [unrestricted] for unrestricted
  unrestricted,

  /// [curb] for curb
  curb,
}

/// [OsrmParameters]
/// Parameters for all OSRM requests.
class OsrmParameters {
  /// [bearings] **Limits** the search to segments with given bearing in degrees towards true north in clockwise direction. Can be used to filter out false matches caused by
  ///   inprecise GPS devices. This parameter is an array of the form [bearing,range], where the first value is the bearing and the second value is the allowed range of
  final List<List<num>>? bearings;

  /// [radiuses] Limits the search to given radius in meters. Can be used to implement distance filters. The parameter can be specified for every coordinate in the request.
  final List<num>? radiuses;

  /// [generateHints] Returns additional metadata for each coordinate along the route geometry. Can also be used to force the tracepoint matching to be used for a specific coordinate.
  final bool? generateHints;

  /// [hints] Hints for each location of the form {hint};{hint};{hint}[;{hint} ...]. A hint is generated by the hint parameter in the response of a previous request. If the
  final List<String>? hints;

  /// [approaches] Defines the approach to a coordinate in the list. Each element in this array is a list of two bearing values: the first is the
  final List<List<OsrmApproach>>? approaches;

  /// [exclude] Exclude certain road classes from routing. Comma-separated list of the following classes: toll, motorway, ferry, tunnel, ford
  final List<String>? exclude;

  /// [snapping] Snap to the nearest road geometry (only available for the driving profile). Can be disabled by setting to false.
  final bool? snapping;

  /// [skipWaypoints] Skips specified waypoints. Waypoints are separated by ;. The number of skip segments must be equal to the number of waypoints. The first waypoint can not be skipped.
  final List<bool>? skipWaypoints;

  /// [classes] Limits the search to the given road classes. Comma-separated list of the following classes: motorway, trunk, primary, secondary, tertiary, residential, unclassified, service, track, cycleway, path
  final List<String>? classes;

  const OsrmParameters({
    this.bearings,
    this.radiuses,
    this.generateHints,
    this.hints,
    this.approaches,
    this.exclude,
    this.snapping,
    this.skipWaypoints,
    this.classes,
  });

  /// [toMap] method to convert the parameters to a map
  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    if (bearings != null) {
      map['bearings'] = bearings!.map((e) => e.join(',')).join(';');
    }
    if (radiuses != null) {
      map['radiuses'] = radiuses!.join(';');
    }
    if (generateHints != null) {
      map['generate_hints'] = generateHints!;
    }
    if (hints != null) {
      map['hints'] = hints!.join(';');
    }
    if (approaches != null) {
      map['approaches'] = approaches!
          .map((e) => e.map((e) => e.toString().split('.').last).join(','))
          .join(';');
    }
    if (exclude != null) {
      map['exclude'] = exclude!.join(',');
    }
    if (snapping != null) {
      map['snapping'] = snapping!;
    }
    if (skipWaypoints != null) {
      map['skip_waypoints'] = skipWaypoints!.join(';');
    }
    if (classes != null) {
      map['classes'] = classes!.join(',');
    }
    return map;
  }
}

/// [OsrmResponseCode] `enum` for the code of the response
enum OsrmResponseCode {
  /// Request could be processed as expected.
  ok,

  /// URL string is invalid.
  invalidUrl,

  /// Service name is invalid.
  invalidService,

  /// Version is not found.
  invalidVersion,

  /// Options are invalid.
  invalidOptions,

  /// The query string is synctactically malformed.
  invalidQuery,

  /// The successfully parsed query parameters are invalid.
  invalidValue,

  /// One of the supplied input coordinates could not snap to street segment.
  noSegment,

  /// The request size violates one of the service specific request size restrictions.
  tooBig;

  /// [fromString] method to get the [OsrmResponseCode] from a string
  static OsrmResponseCode fromString(String code) {
    switch (code) {
      case 'Ok':
        return OsrmResponseCode.ok;
      case 'InvalidUrl':
        return OsrmResponseCode.invalidUrl;
      case 'InvalidService':
        return OsrmResponseCode.invalidService;
      case 'InvalidVersion':
        return OsrmResponseCode.invalidVersion;
      case 'InvalidOptions':
        return OsrmResponseCode.invalidOptions;
      case 'InvalidQuery':
        return OsrmResponseCode.invalidQuery;
      case 'InvalidValue':
        return OsrmResponseCode.invalidValue;
      case 'NoSegment':
        return OsrmResponseCode.noSegment;
      case 'TooBig':
        return OsrmResponseCode.tooBig;
      default:
        throw Exception('Invalid response code: $code');
    }
  }

  /// [toString] method to get the string from the [OsrmResponseCode]
  @override
  String toString() {
    return name.pascalCase;
  }
}

/// [OsrmResponse] class for all OSRM responses
abstract class OsrmResponse {
  /// [code] the code of the response
  final OsrmResponseCode code;

  /// [message] the message of the response
  final String? message;

  /// [dataVersion] the data version of the response
  final DateTime? dataVersion;
  OsrmResponse({
    required this.code,
    this.message,
    this.dataVersion,
  });
}

/// [OsrmResponseException] class for all OSRM response exceptions
class OsrmResponseException extends OsrmResponse implements Exception {
  OsrmResponseException(
      {required super.code, required super.message, super.dataVersion});
}

/// [OsrmSource] interface for the source of the requests
/// This interface can be implemented by any class.
class OsrmSource {
  /// [client] the http client of the source
  final Client client;

  /// [serverBuilder] the builder of the server uri
  final Uri Function(OsrmRequest options) serverBuilder;

  /// [timeout] the timeout of the source
  final Duration timeout;

  /// [OsrmSource] constructor
  OsrmSource({
    Client? client,
    Uri Function(OsrmRequest options)? serverBuilder,
    this.timeout = const Duration(seconds: 20),
  })  : serverBuilder = serverBuilder ?? OsrmServerBuilder.defaultBuild,
        client = client ?? Client();

  /// [request] method to make the request and return the raw response
  Future<Map<String, dynamic>> request(OsrmRequest options) async {
    try {
      final result = await client.get(
        serverBuilder(options),
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
      ).timeout(timeout);
      // CancellableOperation? operation;
      if (result.statusCode == 200) {
        return parseResponse(result.body);
      } else if (result.statusCode == 400) {
        var data = parseResponse(result.body);
        throw OsrmResponseException(
          code: OsrmResponseCode.fromString(data['code']),
          message: data['message'] ?? '',
        );
      }
      throw Exception('Invalid response code: ${result.statusCode}');
    // ignore: unused_catch_clause, no_leading_underscores_for_local_identifiers
    } on OsrmResponseException catch (_e) {
      rethrow;
    // ignore: unused_catch_clause, no_leading_underscores_for_local_identifiers
    } on Exception catch (_e) {
      rethrow;
    }
  }

  // /// [request] method to make the request
  // /// if error occurs, the method should throw [OsrmResponseException]
  // /// if other error occurs, the method should throw [Exception]
  // Future<OsrmResponse> request(OsrmOptions options);
  /// [parseResponse] method to parse the response
  Map<String, dynamic> parseResponse(String response) {
    final map = jsonDecode(response);
    return map;
  }

  // TODO: implement isolate support to parse the response in a separate isolate
  // /// [_parseResponse] method to parse the response
  // /// it uses [Isolate.run] to run the parsing in a separate isolate if possible
  // Future<OsrmResponse> _parseResponse(OsrmOptions options, String response) async {
  //   try {
  //     return await Isolate.run(
  //       _parseResponseIsolate,
  //       response,
  //       debugName: 'parseResponse',
  //     );
  //   } catch (e) {
  //     return _parseResponseIsolate(response);
  //   }
  // }

  // /// [_parseResponseIsolate] method to parse the response in a separate isolate
  // OsrmResponse _parseResponseIsolate(String response) {
  //   // response is a json string
  //   // parse the json string
  //   final map = jsonDecode(response);
  //   final code = OsrmResponseCode.fromString(map['code']);
  // }
}

/// [OsrmGeneralRequest]
/// General options for all OSRM requests.
class OsrmGeneralRequest extends OsrmRequest {
  OsrmGeneralRequest({
    required super.service,
    super.version,
    super.profile,
    required super.coordinates,
    super.format,
    super.parameters,
  });

  @override
  Map<String, dynamic> get extraQueryParameters => const {};
}

/// [OsrmRequest] abstract class for all OSRM requests
abstract class OsrmRequest {
  /// [service] the service to use for the request its [OsrmService]
  final OsrmService service;

  /// [version] Version of the protocol implemented by the service. v1 for all OSRM 5.x installations
  final String version;

  /// [profile] Specifies the mode of transportation, its [OsrmRequestProfile]
  final OsrmRequestProfile profile;

  /// [coordinates] String of format {longitude},{latitude};{longitude},{latitude}[;{longitude},{latitude} ...] or polyline({polyline}) or polyline6({polyline6})
  final List<OsrmCoordinate> coordinates;

  /// [format] its not used in this SDK (always json)
  final OsrmFormat format;

  /// [parameters] extra parameters for the request
  final OsrmParameters? parameters;

  OsrmRequest({
    required this.service,
    this.version = 'v1',
    this.profile = OsrmRequestProfile.car,
    required this.coordinates,
    this.format = OsrmFormat.json,
    this.parameters = const OsrmParameters(),
  }) : // make sure this.format is always json
        assert(format == OsrmFormat.json,
            'format must be json, so why i added it?, just for fun :) + may use it in the future');

  String get stringCoordinates => coordinates.map((c) {
        return c.toLongLatCoordinateString();
      }).join(';');

  /// [inject] method to inject the parameters into the request url
  Uri inject(String server) {
    var urlToParse =
        '$server/${service.toString().split('.').last}/$version/${profile.name}/${coordinates.map((e) => e.toLongLatCoordinateString()).join(';')}';
    if (queryParameters.isNotEmpty) {
      urlToParse += '?';
      urlToParse +=
          queryParameters.entries.map((e) => '${e.key}=${e.value}').join('&');
    }
    return Uri.parse(urlToParse);
  }

  Map<String, dynamic> get queryParameters => {
        ...(parameters?.toMap() ?? const {}),
        ...extraQueryParameters,
      };

  /// [extraQueryParameters] method to get the extra parameters of the request
  Map<String, dynamic> get extraQueryParameters;
}
